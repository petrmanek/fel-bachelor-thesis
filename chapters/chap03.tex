\chapter{Communication Protocol}
\label{protocol:introduction}

In this chapter, we move our focus from the data itself to the JSON Timepix Protocol, a communication protocol we use to transmit the data for the purposes of visualization. We describe overall scheme of communication and define JSTP in a formal way.

\section{Client-Server Model}
In the previous chapter, we have defined a database capable of storing footage captured by the ATLAS-TPX network at CERN. Since this database is based on a file system, multiple users can access it simultaneously by either logging on to the computer which manages the file system, or by using some of supported\footnote{Recall that in section \ref{db:supported-protocols} we define that our database supports FTP, SMB, SSH, AFP and HTTP access.} network protocols. Since these protocols use a client-server communication model in their definition, it makes sense to do the same in JSTP as well.

Before we continue, we need to ask ourselves an important question. Why would we define and implement a new communication protocol for a proprietary data format? Since our database already supports network access for multiple users, we would not gain any new features, so what other benefits could there be? The primary motivation for the existence of JSTP is the web visualization UI. In it, our users want to observe recorded footage frame by frame. If we do not define our own protocol to transmit individual frames, we are bound to use one of storage formats listed in section \ref{db:storage-formats}, none of which are particularly suitable for this task, and for network transfers in general. For instance, Multi-Frame stores data in multiple files, implying that several parallel downloads would be required to display even one frame, possibly putting a strain on user's network connection in the process. ROOT uses its own compression algorithms, making it non-trivial to deflate in a website context. Lastly, since both ROOT and Multi-Frame store data in bulks, the information overhead to transmit just one frame would be unbearable, especially considering that files in question may be several gigabytes in size.

With this motivation in mind, let us now state few more assumptions about our web visualization. We expect to have multiple users connecting to our server over a local area network or through the Internet. We assume that our users want to see and possibly further inspect some of the frames captured by the ATLAS-TPX network, transmitted one at a time.

We do not design JSTP to transmit all information from our data files, nor do we want to send continuous footage at streaming speeds. Instead, we define JSTP to enable simple access to detector data, and to provide a brief overview of recent detector operation with emphasis on any irregular or pattern-defying events.

\subsection{Considerations}
It is worth noting that in designing our system, we would like to uphold a multi-layered architecture. This way, we will maintain strict distinctions between individual components of the system (and the tasks they perform), making them in effect easily extendable, substitutable and perhaps even portable to other applications. Other benefit of this approach is that users of our system will always have freedom to choose a component with which they wish to interact, in turn specifying the level of offered services, speed and complexity.

\begin{figure}[t]
\begin{center}
	\begin{tikzpicture}[node distance=3pt,
	blueb/.style={
	  draw=black,
	  rounded corners,
	  text width=2.5cm,
	  font=\scriptsize,
	  align=center,
	  text height=12pt,
	  text depth=9pt
	},
	layerb/.style={
	  blueb,
	  draw=none
	},
	proprietaryb/.style={
	  blueb,
	  fill=gray!30
	}]

	\node[layerb] (Clients) {\textbf{Applications}};
	\node[proprietaryb,right=of Clients,text width=5cm+10pt] (VizUI) {Web visualization UI};
	\node[blueb,right=of VizUI,text width=5cm+10pt] (Apps) {Others \dots};

	\node[layerb,below=of Clients] (Protocols) {\textbf{Protocols}};
	\node[proprietaryb,right=of Protocols] (JSTP) {JSTP};
	\node[blueb,right=of JSTP] (HTTP) {HTTP};
	\node[blueb,right=of HTTP] (FileP) {FTP, SMB};
	\node[blueb,right=of FileP] (SQLP) {SQL queries};

	\node[layerb,below=of Protocols] (Servers) {\textbf{Servers}};
	\node[proprietaryb,right=of Servers] (DataS) {Data RPC};
	\node[blueb,right=of DataS] (WebS) {Static web};
	\node[blueb,right=of WebS] (FileS) {File servers};
	\node[blueb,right=of FileS] (SQLS) {PostgreSQL};

	\node[layerb,below=of Servers] (Data) {\textbf{Data Store}};
	\node[blueb,right=of Data] (ROOT) {ROOT};
	\node[blueb,right=of ROOT,text width=5cm+10pt] (MF) {Multi-frame \& single-frame};
	\node[proprietaryb,right=of MF] (SQLD) {Index DB};

	\node[blueb,below=2.4cm of HTTP,text width=13cm+26pt] (FileSystem) {UNIX-like file system (possibly EOS)};

	\begin{pgfonlayer}{background}
	\draw[blueb,draw=black] 
	  ([xshift=-8pt,yshift=8pt]current bounding box.north west) rectangle 
	  ([xshift=8pt,yshift=-8pt]current bounding box.south east);
	\end{pgfonlayer}
	\end{tikzpicture}

\caption{A multi-layered system. Proprietary components are emphasized by gray color.}
\label{fig:multilayered-diagram}
\end{center}
\end{figure}

We may imagine this as follows. Users, who want a quick peek at the detector operation without any effort, may use the web visualization UI. Users, who want to retrieve data for experimentation or statistical aggregation, might utilize SQL or the communication protocol we define in this very chapter. Lastly, users in need of data enumeration or manipulation can connect to the database storage device and directly download data files using some of the supported network transfer protocols. This concept is illustrated in Figure \ref{fig:multilayered-diagram}.

% CITACE: konkurenční projekty
We should also consider extensibility of JSTP in the future. With multiple concurrent projects such as MoEDAL-TPX\footnote{Similarly to ATLAS-TPX, MoEDAL-TPX is a network of Timepix devices installed within the MoEDAL experiment at CERN.}, SATRAM\footnote{SATRAM is a technology demonstration device carrying Timepix position-sensitive semiconductor pixel detector on board ESA’s Proba V satellite. \url{http://satram.utef.cvut.cz/}} and RISESat\footnote{RISESat is a microsatellite mission carrying several scientific instruments including a Timepix detector.}, it is likely that JSTP will be used for compatibility reasons in other applications as well. It should therefore allow for limited variability, gracefully handling minor alterations in transmitted data structures.

\subsection{Requirements}
The most basic requirement on JSTP is that it allows us to retrieve frames captured by the ATLAS-TPX network by the time and the device of origin. This might remind us of a similar requirement in the database definition (see section \ref{db:definition}), as it is the most likely user request. But unlike the database, JSTP should be able to transmit only those frames, which conform to request's predicate, minimizing information overhead in responses.

Moreover, we require JSTP to transmit results of cluster analysis, possibly leaving the door open for pixel matrix transmissions in the future. This means that every frame transmitted through JSTP will have to consist of two parts: a header (containing detector configuration, position, etc.) and a body (cluster list, possibly a pixel matrix). In order to specify from which network device the data must originate, we require that JSTP provides a list of devices in the network. This might seem redundant at first, but consider that we need to be ready for situations when devices malfunction, are replaced, or new elements of the network are installed. Lastly, since JSTP will provide us with a list of sensors and frames from any of them at any time of operation, we require that it offers us a simple overview of sensor operation in a given time interval, expressed in average frame occupancy and cluster counts (possibly differentiated by cluster types).

Apart from the file management network protocols we listed earlier, we do not place any data manipulation requirements on JSTP, implying that the protocol cannot be used for other than read-only access.

\section{Definition}
In this section, we define the JSON Timepix Protocol.

\subsection{Underlying Standards}
JSTP is web protocol and as such, it utilizes HTTP as its underlying standard. In its architecture, the protocol can be considered a web service providing API for remote procedure calls (RPC). Since JSTP is does not include any universal service description like WSDL, any client will need to know its capabilities and calling conventions prior to initiating communication.

For data serialization, JSTP utilizes JavaScript Object Notation (also known by its MIME designation: \texttt{application/json}). This format was chosen for several reasons. It is simple to parse, offers an extensible tree structure and is very common among web services of this kind, as it is directly supported by JavaScript client-side runtime, which is used in the web visualization UI. In compliance with the common expectation, JSTP methods may sometimes require additional arguments. Should such situation arise, all parameters need to be provided in a JSON object, serialized and transmitted in a body of an HTTP POST request.

Observant readers may ask whether JSTP conforms to standards of a RESTful web services. While it is true that the protocol shows many traits often attributed to RESTful services (client-server model, stateless protocol, cacheability, layered system), it certainly does not satisfy all of them. For instance, JSTP does not uniquely identify resources by their URI because it uses identifiers established by the database (recall members \texttt{fid}, \texttt{frid} and \texttt{sid} of entities defined in section \ref{db:definition}). Moreover, JSTP does not offer uniform interface, capable of negotiating data format according to client limitations. Instead, it forces clients to communicate strictly in JSON, adhering to its own data structures and calling conventions.

\subsection{Web Methods}
JSTP has multiple components, one of which is a web service, which can be described as a set of dedicated web methods. In this section, we provide such a description. Note that when referring to the service endpoint in method URLs, we use \texttt{<endpoint>} as a stand-in string.

\begin{description}
	\item[Device List]
	\texttt{GET http://<endpoint>/sensors}

	Purpose of this method is to provide an updated list of operational devices in the ATLAS-TPX network. As we mentioned earlier, we need to be ready for situations when detectors malfunction, are replaced or new ones are added. For this reason, any client intending to retrieve frames from a specific device must first consult the list provided by this method to verify, whether the device is still connected and operational. In addition, other clients unaware of network architecture may use this method to obtain an exhaustive listing of all available data sources.

	To execute this method, a client must initiate HTTP GET request to the method URL without any parameters. When successful, the server responds by returning an array of objects, each of which corresponds to a single device in the network. Example of such response is provided in Listing \ref{lst:jstp-sensors}.

	\begin{listing}
		\inputjson{code/jstp-sensors.json}
	    \caption{Example response containing a list of two devices.}
	    \label{lst:jstp-sensors}
	\end{listing}

	Every object in the array is guaranteed to contain \texttt{sid}, a unique numeric identifier of the device retrieved from the index database, and \texttt{name}, a readable name of the sensor.

	\item[Operation Overview]
	\texttt{POST http://<endpoint>/timeline}

	Purpose of this method is to inform user about operation of a device (or a set of devices) in a time period, possibly indicating frames of interest. The server achieves that effect by aggregating all relevant frames into subgroups based on their start time, and calculating statistics for every group.

	Clients calling this method are required to specify five parameters. The time period, bounded by \texttt{startTime} and \texttt{endTime}, is divided into finitely many intervals, length of which is controlled by \texttt{groupPeriod}. Source devices are referenced by values of their \texttt{sid} in the \texttt{sensors} array. In every time interval, frames captured by the referenced devices are considered if their start time falls into time bounds of the interval. Since some of the calculated statistics are dependent on acquisition time, which may vary between individual frames, it is possible to compensate by setting the \texttt{normalize} parameter, obtaining flux instead of aggregated values.

	To execute this method, a client must initiate HTTP POST request to the method URL. The request body must contain a JSON object with \textit{all} parameter values. You can examine an example request in Listing \ref{lst:jstp-timeline-request}.

	\begin{listing}
		\inputjson{code/jstp-timeline-request.json}
	    \caption{Example request with time period starting at the midnight of July 28, 2015 and ending at the midnight of July 29, 2015. Data from two detectors is requested to be normalized and grouped by every hour.}
	    \label{lst:jstp-timeline-request}
	\end{listing}



	\item[Frame Search]
	\texttt{POST http://<endpoint>/frame}
\end{description}

\subsection{Calling Scheme}
%  - Návrh technického formátu protokolu.

\subsection{Miscellaneous}
%  - cache
%  - rozšiřitelnost
%  - zabezpečení
%  - přesnost čísel

\section{Documentation}

